
□ F_CLEAN_UP - 提供繼承這項特徵的物件一個標準的 clean_up 函數。

    每當一個物件在隔了一段固定長度時間沒有被其他物件參考到﹐MudOS 會呼
叫該物件的 clean_up 函數以檢查這個物件是否有繼續存在的必要﹐也就是說﹐
如果這個物件有一段時間沒有被使用到﹐也許物件已經沒有用了﹐可以將它從記
憶體中清除以節省空間﹐例如﹕一個很久沒有人走過的房間。

    clean up 時間的長短是在 MudOS 的 runtime config 檔裡設定的。所有可
以被 clone 的物件、房間、指令處理物件、以及非長駐型 daemon都應該要繼承
這項特徵以便能在物件不被使用到時加以摧毀並釋放出所佔記憶體。
 
    當此函數傳回 1 時﹐意思是告訴 MudOS 「我現在暫時要繼續留在記憶體中
﹐但是如果再隔一段固定長度時間這個物件仍然沒有被其他物件參考到﹐請你再
呼叫一次我的 clean_up() 函數」﹐若傳回 0 或是 clean_up  函數沒有被定義
﹐則 MudOS 會假設這個物件不需要 clean up這種服務﹐以後就不會再呼叫這個
物件的 clean_up()。

標準的 clean_up() 判定程序﹕
 
    首先﹐如果這個物件是一個使用者 (用 interactive() 決定)﹐此函數傳回
 1﹐因為使用者發呆過久是在 heart beat 裡處理的。
 
    接下來﹐如果這個物件是在另一個物件裡﹐例如一個房間裡的怪物、袋子裡
的物品等等﹐我們改呼叫含有這個物件的房間或袋子的 clean_up() ﹐這樣做有
兩個主要理由﹕如果同一個房間裡有不能被 clean up 的物件﹐如玩家﹐那麼我
們不希望任何物件在他們面前憑空消失﹐而且﹐如果一個存在於另一物件中的物
件能夠被清除﹐容納它的物件必定也能夠被清除﹐如果容納它的物件不能被清除
﹐那麼這個物件也必定不能被清除﹐如玩家身上的物件﹐因此我們讓容納這個物
件的物件來決定要不要清除﹐因為清除一個物件的同時﹐也會清除這個物件裡的
所有物件。
 
    如果這個物件並不是在另一個物件裡﹐而是一個房間﹐我們還必須檢查是否
有玩家在這個房間裡﹐以免玩家發呆了一會兒就被踢到最後樂園去。
 
    最後﹐經過以上各個關卡﹐我們判定這個物件已經沒有存在的必要﹐所以我
們將這個物件摧毀﹐傳回 0 用以告知 MudOS 這個物件已經「不見了」以後不用
再檢查它是否需要 clean up  。
 
[Elon 12-12-94]
[Annihilator 12-13-94]
